[toc]
# reactäº‹ä»¶ç³»ç»Ÿ
reactçš„äº‹ä»¶ç³»ç»Ÿå¤§è‡´åŸç†æ˜¯é¦–å…ˆåœ¨mountæˆ–updateDomPropertiesæ—¶æŠŠå¯¹åº”çš„äº‹ä»¶éƒ½ç»‘å®šåœ¨documentä¸Šï¼Œç„¶åç”¨æˆ·è§¦å‘æ—¶é€šè¿‡ ReactEventListener è¿›è¡Œäº‹ä»¶æ´¾å‘ï¼Œä»è€Œå“åº”äº‹ä»¶hanlder

ä¸‹é¢è¿½è¸ªä¸€ä¸‹æºç 
## mountæˆ–upateæ—¶çš„äº‹ä»¶ç»‘å®š
```js
  _updateDOMProperties: function(lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {  // æœ¬æ¬¡å¾ªç¯å¤„ç†éœ€è¦æ¸…é™¤çš„lastPropsé¡¹
      if (nextProps.hasOwnProperty(propKey) || // å¦‚æœnextPropsæœ‰ propKey åˆ™æš‚æ—¶ä¸ç®¡
         !lastProps.hasOwnProperty(propKey) ||
         lastProps[propKey] == null) {
        continue;
      }
      // else nextProps ä¸åŒ…å«è¿™äº› propKey ï¼Œéœ€è¦æ¸…é™¤
      if (propKey === STYLE) { // å¦‚æœ propKey æ˜¯ styleåˆ™ æŠŠ styleUpdatesçš„æ‰€æœ‰lastStyleæ‹¥æœ‰çš„å±æ€§çš„å±æ€§å€¼éƒ½ç½®ä¸º''
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) { // å¦‚æœæ˜¯å·²ç»æ³¨å†Œè¿‡çš„äº‹ä»¶å±æ€§åæ¯”å¦‚onClick, onChangeç­‰
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(
            getNode(this),
            propKey
          );
        }
      } else if (
          DOMProperty.properties[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) { // æœ¬æ¬¡å¾ªç¯å¤„ç†éœ€è¦æ›´æ–°çš„nextProps
      var nextProp = nextProps[propKey];
      var lastProp =
        propKey === STYLE ? this._previousStyleCopy :
        lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) ||
          nextProp === lastProp ||
          nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (__DEV__) {
            checkAndWarnForMutatedStyle(
              this._previousStyleCopy,
              this._previousStyle,
              this
            );
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = Object.assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) &&
                (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) &&
                lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) { // äº‹ä»¶ç»‘å®šçš„å±æ€§
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction); // æ·»åŠ äº‹ä»¶ç»‘å®š!!!!!!!!!!!
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(
            getNode(this),
            propKey,
            nextProp
          );
        }
      } else if (
          DOMProperty.properties[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(
        getNode(this),
        styleUpdates,
        this
      );
    }
  }
```

```js
// src/renderers/dom/shared/ReactDOMComponent.js
function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc); // ç»‘å®šäº‹ä»¶!!!!!!!!
  // transaction.getReactMountReady().enqueue å°±æ˜¯æŠŠ putListener å‡½æ•°åŠ å…¥äº†ä¸€ä¸ªcallbacké˜Ÿåˆ—
  transaction.getReactMountReady().enqueue(putListener, { // å¤„ç†äº‹ä»¶handler
    inst: inst,
    registrationName: registrationName,
    listener: listener,
  });
}
function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(
    listenerToPut.inst,
    listenerToPut.registrationName,
    listenerToPut.listener
  );
}
```
è¿™é‡Œçš„transactionæ˜¯ReactUpdates.ReactReconcileTransactionçš„å®ä¾‹ï¼ˆè¯¦è§[ReactUpdates.ReactReconcileTransaction](./1~3~1ReactUpdates.ReactReconcileTransaction.md)ï¼‰

å­˜å‚¨å¯¹åº”çš„äº‹ä»¶handlerçš„è¿‡ç¨‹è¯¦è§[3~1å­˜æ”¾äº‹ä»¶handlerçš„è¿‡ç¨‹](./3~1å­˜æ”¾äº‹ä»¶handlerçš„è¿‡ç¨‹.md)

```JS
    var markup = ReactReconciler.mountComponent(
      child,
      transaction,
      hostParent,
      hostContainerInfo,
      this._processChildContext(context),
      debugID
    );

        var markup = internalInstance.mountComponent(
      transaction,
      hostParent,
      hostContainerInfo,
      context,
      parentDebugID
    );
```



```js
var ReactBrowserEventEmitter = {
  // ...
  listenTo: function(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies =
      EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(
            isListening.hasOwnProperty(dependency) &&
            isListening[dependency]
          )) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topWheel',
              'wheel',
              mountAt
            );
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topWheel',
              'mousewheel',
              mountAt
            );
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topWheel',
              'DOMMouseScroll',
              mountAt
            );
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              'topScroll',
              'scroll',
              mountAt
            );
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topScroll',
              'scroll',
              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
            );
          }
        } else if (dependency === 'topFocus' ||
            dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              'topFocus',
              'focus',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              'topBlur',
              'blur',
              mountAt
            );
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topFocus',
              'focusin',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              'topBlur',
              'focusout',
              mountAt
            );
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) { 
          // ç»‘å®šäº‹ä»¶ ï¼ï¼ï¼ï¼
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
            dependency,
            topEventMapping[dependency],
            mountAt
          );
        }

        isListening[dependency] = true;
      }
    }
  },
  // ...
}

```

```js
var ReactEventListener = {
  // ...
  trapBubbledEvent: function(topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType) // å“åº”ç”¨æˆ·äº‹ä»¶æ´¾å‘ReactEvent
    );
  },
  // ...
}


```

## å“åº”ç”¨æˆ·è§¦å‘çš„äº‹ä»¶

```JS
// ReactEventListener.dispatchEvent
var ReactEventListener = {
  // ...
  dispatchEvent: function(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
      topLevelType,
      nativeEvent
    );
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  },
  // ...
}
```

```JS
// handleTopLevelImpl
function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(
    nativeEventTarget
  );

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel( // ğŸ™‚
      bookKeeping.topLevelType,
      targetInst,
      bookKeeping.nativeEvent,
      getEventTarget(bookKeeping.nativeEvent)
    );
  }
}
```
```JS
// ReactEventListener._handleTopLevel
var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget) {
    var events = EventPluginHub.extractEvents( // ğŸ™‚
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget
    );
    runEventQueueInBatch(events); // ğŸ™‚
  },
};
```

```JS
// src/renderers/shared/stack/event/EventPluginHub.js
var EventPluginHub = {
  extractEvents: function(
      topLevelType,
      targetInst,
      nativeEvent,
      nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },
}
```
å…³äº EventPluginRegistry.plugins è¯¦è§[3~2EventPluginRegistry.plugins](./3~2EventPluginRegistry.plugins.md)
```js
function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events); // ğŸ™‚
  EventPluginHub.processEventQueue(false); // ğŸ™‚
}
```

```js
// src/renderers/shared/stack/event/EventPluginHub.js
var EventPluginHub = {
  // ...
  enqueueEvents: function(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events); // ğŸ™‚ accumulateInto åˆå¹¶å‚æ•°ä¸ºæ•°ç»„
    }
  },
  processEventQueue: function(simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(
        processingEventQueue,
        executeDispatchesAndReleaseSimulated
      );
    } else {
      forEachAccumulated( // ğŸ™‚ éå†æ•°ç»„æ‰§è¡Œcb æˆ–è€…éæ•°ç»„ç›´æ¥æ‰§è¡Œcb
        processingEventQueue,
        executeDispatchesAndReleaseTopLevel
      );
    }
    invariant(
      !eventQueue,
      'processEventQueue(): Additional events were enqueued while processing ' +
      'an event queue. Support for this has not yet been implemented.'
    );
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },
  // ...
}
```
```JS
// src/renderers/shared/stack/event/EventPluginHub.js
var executeDispatchesAndReleaseTopLevel = function(e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function(event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

```
```JS
// src/renderers/shared/stack/event/EventPluginUtils.js
/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners; // å–å‡ºäº‹ä»¶å¤„ç†å‡½æ•°ï¼ï¼ï¼ï¼ï¼å›è¿‡å»çœ‹eventçš„åˆ›å»º
  var dispatchInstances = event._dispatchInstances;
  if (__DEV__) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(
        event,
        simulated,
        dispatchListeners[i],
        dispatchInstances[i]
      );
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances); // ğŸ™‚
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(
      type,
      listener,
      event
    );
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event); // ğŸ™‚
  }
  event.currentTarget = null;
}
```
```JS
// src/renderers/shared/utils/ReactErrorUtils.js

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback<A>(
  name: string,
  func: (a: A) => void,
  a: A,
): void {
  try {
    func(a); // æœ€ååœ¨è¿™é‡Œæ‰§è¡Œäº† listener(event)
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}
```

```js
// src/renderers/shared/utils/accumulateInto.js
function accumulateInto<T>(current: ?(T | Array<T>), next: T | Array<T>): T | Array<T> {
  invariant(
    next != null,
    'accumulateInto(...): Accumulated items must not be null or undefined.'
  );

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}
```
```js
// src/renderers/shared/utils/forEachAccumulated.js

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
function forEachAccumulated<T>(
  arr: ?(T | Array<T>),
  cb: ((elem: T) => void),
  scope: ?any,
) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}
```