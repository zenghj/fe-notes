[toc]
# setStateçš„åŒæ­¥ä¸Žå¼‚æ­¥
ä¹‹å‰ä¸€ç›´ä»¥ä¸ºreactçš„setStateå¯èƒ½æ˜¯åŒæ­¥æˆ–è€…å¼‚æ­¥æ›´æ–°stateï¼Œè‡³äºŽå…·ä½“ç­–ç•¥ç”±reactå†³å®šï¼ŒåŽæ¥å¬è¯´è¿˜èƒ½è‡ªå·±æŽ§åˆ¶ðŸ˜²
## ä»Žä¸€é“é¢˜è¯´èµ·
çœ‹çœ‹ä¸‹é¢è¿™ä¸ªä¾‹å­ä¼šè¾“å‡ºå•¥
```js
import React, { Component } from 'react';

class App extends Component{
  constructor(props){
    super(props)
    this.state = {
      val:0
    }
  }

  componentDidMount(){
    this.setState({val: this.state.val + 1})
    console.log(this.state.val)

    this.setState({val: this.state.val + 1})
    console.log(this.state.val)

    this.timer = setTimeout(() => {
      console.log(this.state.val)
      this.setState({val: this.state.val + 1})
      console.log(this.state.val)

      this.setState({val: this.state.val + 1})
      console.log(this.state.val)
    },0)
  }

  componentWillUnmount(){
    clearTimeout(this.timer)
  }

  render(){
    return <div>{this.state.val}</div>
  }
}


export default App


/* è¾“å‡º
0
0
1
2
3
*/
```
## ä»Žæºç è§’åº¦æ¥çœ‹çœ‹ä¸ºä»€ä¹ˆ
ä¸ºä»€ä¹ˆå‘¢ï¼Œå¦‚æžœä¸äº†è§£setStateçš„æºç ï¼Œææ€•ä¸€è„¸æ‡µé€¼ðŸ˜²
ä»Žreactæºç å¯ä»¥çœ‹åˆ°ï¼š
```JS
// å·²åˆ æŽ‰éƒ¨åˆ†æ— å…³ä»£ç 
ReactComponent.prototype.setState = function(partialState, callback) {
  this.updater.enqueueSetState(this, partialState); // !!!!!!!!
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
```
åœ¨`ReactCompositeComponent.mountComponent`ä¸­æˆ‘ä»¬å¯¹updaterè¿›è¡Œäº†åˆå§‹åŒ–
```JS
var updateQueue = transaction.getUpdateQueue(); 
inst.updater = updateQueue;

```
è¿™é‡Œçš„ transaction æ˜¯ReactReconcileTransactionçš„å®žä¾‹ï¼Œè¯¦è§ [2~1.ReactReconcileTransaction](./2~1.ReactReconcileTransaction.md)

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ReactComponentçš„æ‰€æœ‰å®žä¾‹çš„this.updater éƒ½æ˜¯ ReactUpdateQueueè¿™ä¸€ä¸ªé˜Ÿåˆ—
ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹ ReactUpdateQueue çš„å®žçŽ°

```js
// src/renderers/shared/stack/reconciler/ReactUpdateQueue.js
var ReactUpdateQueue = {

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function(publicInstance, partialState) {

    var internalInstance = getInternalInstanceReadyForUpdate(
      publicInstance,
      'setState'
    );

    if (!internalInstance) {
      return;
    }

    var queue =
      internalInstance._pendingStateQueue ||
      (internalInstance._pendingStateQueue = []);
    queue.push(partialState); // ðŸ™‚ï¼Œåœ¨è¿™é‡ŒæŠŠpartialStateå­˜æ”¾è¿›internalInstance._pendingStateQueue

    enqueueUpdate(internalInstance); // ðŸ™‚
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function(publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },
}

function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    // è¿™é‡Œä¼šåŒæ­¥æ›´æ–°state
    batchingStrategy.batchedUpdates(enqueueUpdate, component); // è°ƒç”¨enqueueUpdate(component), ç„¶åŽæ›´æ–°ç»„ä»¶
    return;
  }
  
  // else å¼‚æ­¥æ›´æ–°
  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}



```
**æ‰€ä»¥setStateæ˜¯å¼‚æ­¥è¿˜æ˜¯åŒæ­¥æ›´æ–°stateå…³é”®çœ‹batchingStrategy.isBatchingUpdatesä¸ºtrueè¿˜æ˜¯false**

### ç‰¹å®šåœºæ™¯
#### äº‹ä»¶å¤„ç†å‡½æ•°è°ƒç”¨ setState
##### react jsxä»£ç ä¸­`onClick={() => {this.setState({count: 1})} }`
è¿™ç§åœºæ™¯ä¸‹ä¼šè§¦å‘reactçš„äº‹ä»¶ï¼Œæ­¤æ—¶onClickå›žè°ƒæ‰§è¡Œä¹‹å‰batchingStrategy.isBatchingUpdatesä¼šè¢«reactåˆ»æ„ç½®æˆtrue(ä¼šè°ƒç”¨`ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping)`ï¼ŒReactUpdates.batchedUpdatesä¼šå°†isBatchingUpdatesç½®æˆtrue)ï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µä¸‹setStateéƒ½æ˜¯å¼‚æ­¥æ›´æ–°state

##### é€šè¿‡addEventListenerç›´æŽ¥ç»‘å®šåŽŸç”Ÿäº‹ä»¶
è¿™ç§æƒ…å†µä¸‹è§¦å‘åŽŸç”Ÿäº‹ä»¶æ‰§è¡Œäº‹ä»¶å¤„ç†å‡½æ•°æ—¶ ç”±äºŽæ²¡æœ‰reactåˆ»æ„æŠŠbatchingStrategy.isBatchingUpdatesç½®æˆtrueï¼ŒsetStateéƒ½æ˜¯åŒæ­¥æ›´æ–°state

#### setTimeout / setInterval / Promise.resolve().then(callback) å›žè°ƒä¸­è°ƒç”¨ setState
åœ¨è¿™äº›åœºæ™¯çš„callbackä¸­æ‰§è¡ŒsetStateæ—¶batchingStrategy.isBatchingUpdateséƒ½è‚¯å®šæ˜¯falseï¼ˆå› ä¸ºjsä¸å¯èƒ½åŒæ—¶æ‰§è¡Œæ‰¹é‡æ›´æ–°çš„æ“ä½œå’ŒsetTimeout/setInterval/Promise.resolveçš„å›žè°ƒï¼‰æ‰€ä»¥ä¹Ÿä¼šæ˜¯åŒæ­¥æ›´æ–°state

æ‰€ä»¥çŽ°åœ¨æ‡‚äº†å—ðŸ™‚

å½“ç„¶ï¼Œå®žé™…ä½¿ç”¨ä¸­å¹¶ä¸æŽ¨èé€šè¿‡è¿™äº›æ–¹å¼å®žçŽ°åŒæ­¥æ›´æ–°stateï¼Œæœ‰éœ€è¦æ—¶è¿˜æ˜¯è€è€å®žå®žç”¨`this.setState((prevState) => {})`