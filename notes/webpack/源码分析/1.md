[toc]

# 流程

## 编译起点

webpack 有两种启动方式：

1. 通过 webpack-cli 脚手架来启动

```bash
webpack ./debug/index.js --config ./debug/webpack.config.js
```

2. 通过 require('webpack')引入包的方式执行

其实第一种方式最终还是会用 require 的方式来启动 webpack，具体可以查看`./bin/webpack.js`文件

```js
const webpack = require('webpack') // 直接使用源码中的webpack函数
const config = require('./webpack.config')
const compiler = webpack(config)
compiler.run((err, stats) => {
  if (err) {
    console.error(err)
  } else {
    // console.log(stats)
    console.log('success')
  }
})
```

### compiler = webpack(config)

lib/webpack.js

```js
const webpack = (options, callback) => {
  const webpackOptionsValidationErrors = validateSchema(
    webpackOptionsSchema,
    options
  )
  if (webpackOptionsValidationErrors.length) {
    throw new WebpackOptionsValidationError(webpackOptionsValidationErrors)
  }
  let compiler
  if (Array.isArray(options)) {
    compiler = new MultiCompiler(options.map(options => webpack(options)))
  } else if (typeof options === 'object') {
    options = new WebpackOptionsDefaulter().process(options)

    compiler = new Compiler(options.context)
    compiler.options = options
    new NodeEnvironmentPlugin().apply(compiler)
    if (options.plugins && Array.isArray(options.plugins)) {
      for (const plugin of options.plugins) {
        plugin.apply(compiler)
      }
    }
    compiler.hooks.environment.call()
    compiler.hooks.afterEnvironment.call()
    compiler.options = new WebpackOptionsApply().process(options, compiler)
  } else {
    throw new Error('Invalid argument: options')
  }
  if (callback) {
    if (typeof callback !== 'function') {
      throw new Error('Invalid argument: callback')
    }
    if (
      options.watch === true ||
      (Array.isArray(options) && options.some(o => o.watch))
    ) {
      const watchOptions = Array.isArray(options)
        ? options.map(o => o.watchOptions || {})
        : options.watchOptions || {}
      return compiler.watch(watchOptions, callback)
    }
    compiler.run(callback)
  }
  return compiler
}
```

#### options = new WebpackOptionsDefaulter().process(options)

这一步主要完成一些 options 里的初始值的设置

lib/WebpackOptionsDefaulter.js

```js
class WebpackOptionsDefaulter extends OptionsDefaulter {
  constructor() {
    super()

    this.set('entry', './src')

    this.set('devtool', 'make', options =>
      options.mode === 'development' ? 'eval' : false
    )
    this.set('cache', 'make', options => options.mode === 'development')

    this.set('context', process.cwd())
    this.set('target', 'web')

    this.set('module', 'call', value => Object.assign({}, value))
    this.set('module.unknownContextRequest', '.')
    this.set('module.unknownContextRegExp', false)
    this.set('module.unknownContextRecursive', true)
    this.set('module.unknownContextCritical', true)
    this.set('module.exprContextRequest', '.')
    this.set('module.exprContextRegExp', false)
    this.set('module.exprContextRecursive', true)
    this.set('module.exprContextCritical', true)
    this.set('module.wrappedContextRegExp', /.*/)
    this.set('module.wrappedContextRecursive', true)
    this.set('module.wrappedContextCritical', false)
    this.set('module.strictExportPresence', false)
    this.set('module.strictThisContextOnImports', false)
    this.set('module.unsafeCache', 'make', options => !!options.cache)
    this.set('module.rules', [])
    this.set('module.defaultRules', 'make', options => [
      {
        type: 'javascript/auto',
        resolve: {}
      },
      {
        test: /\.mjs$/i,
        type: 'javascript/esm',
        resolve: {
          mainFields:
            options.target === 'web' ||
            options.target === 'webworker' ||
            options.target === 'electron-renderer'
              ? ['browser', 'main']
              : ['main']
        }
      },
      {
        test: /\.json$/i,
        type: 'json'
      },
      {
        test: /\.wasm$/i,
        type: 'webassembly/experimental'
      }
    ])

    this.set('output', 'call', (value, options) => {
      if (typeof value === 'string') {
        return {
          filename: value
        }
      } else if (typeof value !== 'object') {
        return {}
      } else {
        return Object.assign({}, value)
      }
    })

    this.set('output.filename', '[name].js')
    this.set('output.chunkFilename', 'make', options => {
      const filename = options.output.filename
      if (typeof filename !== 'function') {
        const hasName = filename.includes('[name]')
        const hasId = filename.includes('[id]')
        const hasChunkHash = filename.includes('[chunkhash]')
        // Anything changing depending on chunk is fine
        if (hasChunkHash || hasName || hasId) return filename
        // Elsewise prefix "[id]." in front of the basename to make it changing
        return filename.replace(/(^|\/)([^/]*(?:\?|$))/, '$1[id].$2')
      }
      return '[id].js'
    })
    this.set('output.webassemblyModuleFilename', '[modulehash].module.wasm')
    this.set('output.library', '')
    this.set('output.hotUpdateFunction', 'make', options => {
      return Template.toIdentifier(
        'webpackHotUpdate' + Template.toIdentifier(options.output.library)
      )
    })
    this.set('output.jsonpFunction', 'make', options => {
      return Template.toIdentifier(
        'webpackJsonp' + Template.toIdentifier(options.output.library)
      )
    })
    this.set('output.chunkCallbackName', 'make', options => {
      return Template.toIdentifier(
        'webpackChunk' + Template.toIdentifier(options.output.library)
      )
    })
    this.set('output.globalObject', 'make', options => {
      switch (options.target) {
        case 'web':
        case 'electron-renderer':
        case 'node-webkit':
          return 'window'
        case 'webworker':
          return 'self'
        case 'node':
        case 'async-node':
        case 'electron-main':
          return 'global'
        default:
          return 'self'
      }
    })
    this.set('output.devtoolNamespace', 'make', options => {
      return getDevtoolNamespace(options.output.library)
    })
    this.set('output.libraryTarget', 'var')
    this.set('output.path', path.join(process.cwd(), 'dist'))
    this.set(
      'output.pathinfo',
      'make',
      options => options.mode === 'development'
    )
    this.set('output.sourceMapFilename', '[file].map[query]')
    this.set('output.hotUpdateChunkFilename', '[id].[hash].hot-update.js')
    this.set('output.hotUpdateMainFilename', '[hash].hot-update.json')
    this.set('output.crossOriginLoading', false)
    this.set('output.jsonpScriptType', false)
    this.set('output.chunkLoadTimeout', 120000)
    this.set('output.hashFunction', 'md4')
    this.set('output.hashDigest', 'hex')
    this.set('output.hashDigestLength', 20)
    this.set('output.devtoolLineToLine', false)
    this.set('output.strictModuleExceptionHandling', false)

    this.set('node', 'call', value => {
      if (typeof value === 'boolean') {
        return value
      } else {
        return Object.assign({}, value)
      }
    })
    this.set('node.console', false)
    this.set('node.process', true)
    this.set('node.global', true)
    this.set('node.Buffer', true)
    this.set('node.setImmediate', true)
    this.set('node.__filename', 'mock')
    this.set('node.__dirname', 'mock')

    this.set('performance', 'call', (value, options) => {
      if (value === false) return false
      if (
        value === undefined &&
        (!isProductionLikeMode(options) || !isWebLikeTarget(options))
      )
        return false
      return Object.assign({}, value)
    })
    this.set('performance.maxAssetSize', 250000)
    this.set('performance.maxEntrypointSize', 250000)
    this.set('performance.hints', 'make', options =>
      isProductionLikeMode(options) ? 'warning' : false
    )

    this.set('optimization', 'call', value => Object.assign({}, value))
    this.set('optimization.removeAvailableModules', true)
    this.set('optimization.removeEmptyChunks', true)
    this.set('optimization.mergeDuplicateChunks', true)
    this.set('optimization.flagIncludedChunks', 'make', options =>
      isProductionLikeMode(options)
    )
    // TODO webpack 5 add `moduleIds: "named"` default for development
    // TODO webpack 5 add `moduleIds: "size"` default for production
    // TODO webpack 5 remove optimization.occurrenceOrder
    this.set('optimization.occurrenceOrder', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.sideEffects', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.providedExports', true)
    this.set('optimization.usedExports', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.concatenateModules', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.splitChunks', {})
    this.set('optimization.splitChunks.hidePathInfo', 'make', options => {
      return isProductionLikeMode(options)
    })
    this.set('optimization.splitChunks.chunks', 'async')
    this.set('optimization.splitChunks.minSize', 'make', options => {
      return isProductionLikeMode(options) ? 30000 : 10000
    })
    this.set('optimization.splitChunks.minChunks', 1)
    this.set('optimization.splitChunks.maxAsyncRequests', 'make', options => {
      return isProductionLikeMode(options) ? 5 : Infinity
    })
    this.set('optimization.splitChunks.automaticNameDelimiter', '~')
    this.set('optimization.splitChunks.maxInitialRequests', 'make', options => {
      return isProductionLikeMode(options) ? 3 : Infinity
    })
    this.set('optimization.splitChunks.name', true)
    this.set('optimization.splitChunks.cacheGroups', {})
    this.set('optimization.splitChunks.cacheGroups.default', {
      automaticNamePrefix: '',
      reuseExistingChunk: true,
      minChunks: 2,
      priority: -20
    })
    this.set('optimization.splitChunks.cacheGroups.vendors', {
      automaticNamePrefix: 'vendors',
      test: /[\\/]node_modules[\\/]/,
      priority: -10
    })
    this.set('optimization.runtimeChunk', 'call', value => {
      if (value === 'single') {
        return {
          name: 'runtime'
        }
      }
      if (value === true || value === 'multiple') {
        return {
          name: entrypoint => `runtime~${entrypoint.name}`
        }
      }
      return value
    })
    this.set('optimization.noEmitOnErrors', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.checkWasmTypes', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.mangleWasmImports', false)
    // TODO webpack 5 remove optimization.namedModules
    this.set(
      'optimization.namedModules',
      'make',
      options => options.mode === 'development'
    )
    this.set('optimization.hashedModuleIds', false)
    // TODO webpack 5 add `chunkIds: "named"` default for development
    // TODO webpack 5 add `chunkIds: "size"` default for production
    // TODO webpack 5 remove optimization.namedChunks
    this.set(
      'optimization.namedChunks',
      'make',
      options => options.mode === 'development'
    )
    this.set(
      'optimization.portableRecords',
      'make',
      options =>
        !!(
          options.recordsInputPath ||
          options.recordsOutputPath ||
          options.recordsPath
        )
    )
    this.set('optimization.minimize', 'make', options =>
      isProductionLikeMode(options)
    )
    this.set('optimization.minimizer', 'make', options => [
      {
        apply: compiler => {
          // Lazy load the uglifyjs plugin
          const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
          const SourceMapDevToolPlugin = require('./SourceMapDevToolPlugin')
          new UglifyJsPlugin({
            cache: true,
            parallel: true,
            sourceMap:
              (options.devtool && /source-?map/.test(options.devtool)) ||
              (options.plugins &&
                options.plugins.some(p => p instanceof SourceMapDevToolPlugin))
          }).apply(compiler)
        }
      }
    ])
    this.set('optimization.nodeEnv', 'make', options => {
      // TODO: In webpack 5, it should return `false` when mode is `none`
      return options.mode || 'production'
    })

    this.set('resolve', 'call', value => Object.assign({}, value))
    this.set('resolve.unsafeCache', true)
    this.set('resolve.modules', ['node_modules'])
    this.set('resolve.extensions', ['.wasm', '.mjs', '.js', '.json'])
    this.set('resolve.mainFiles', ['index'])
    this.set('resolve.aliasFields', 'make', options => {
      if (options.target === 'web' || options.target === 'webworker') {
        return ['browser']
      } else {
        return []
      }
    })
    this.set('resolve.mainFields', 'make', options => {
      if (
        options.target === 'web' ||
        options.target === 'webworker' ||
        options.target === 'electron-renderer'
      ) {
        return ['browser', 'module', 'main']
      } else {
        return ['module', 'main']
      }
    })
    this.set('resolve.cacheWithContext', 'make', options => {
      return (
        Array.isArray(options.resolve.plugins) &&
        options.resolve.plugins.length > 0
      )
    })

    this.set('resolveLoader', 'call', value => Object.assign({}, value))
    this.set('resolveLoader.unsafeCache', true)
    this.set('resolveLoader.mainFields', ['loader', 'main'])
    this.set('resolveLoader.extensions', ['.js', '.json'])
    this.set('resolveLoader.mainFiles', ['index'])
    this.set('resolveLoader.cacheWithContext', 'make', options => {
      return (
        Array.isArray(options.resolveLoader.plugins) &&
        options.resolveLoader.plugins.length > 0
      )
    })
  }
}
```

#### Compile

lib/Compiler.js

```js
class Compiler extends Tapable {
  constructor(context) {
    super()
    this.hooks = {
      /** @type {SyncBailHook<Compilation>} */
      shouldEmit: new SyncBailHook(['compilation']),
      /** @type {AsyncSeriesHook<Stats>} */
      done: new AsyncSeriesHook(['stats']),
      /** @type {AsyncSeriesHook<>} */
      additionalPass: new AsyncSeriesHook([]),
      /** @type {AsyncSeriesHook<Compiler>} */
      beforeRun: new AsyncSeriesHook(['compiler']),
      /** @type {AsyncSeriesHook<Compiler>} */
      run: new AsyncSeriesHook(['compiler']),
      /** @type {AsyncSeriesHook<Compilation>} */
      emit: new AsyncSeriesHook(['compilation']),
      /** @type {AsyncSeriesHook<Compilation>} */
      afterEmit: new AsyncSeriesHook(['compilation']),

      /** @type {SyncHook<Compilation, CompilationParams>} */
      thisCompilation: new SyncHook(['compilation', 'params']),
      /** @type {SyncHook<Compilation, CompilationParams>} */
      compilation: new SyncHook(['compilation', 'params']),
      /** @type {SyncHook<NormalModuleFactory>} */
      normalModuleFactory: new SyncHook(['normalModuleFactory']),
      /** @type {SyncHook<ContextModuleFactory>}  */
      contextModuleFactory: new SyncHook(['contextModulefactory']),

      /** @type {AsyncSeriesHook<CompilationParams>} */
      beforeCompile: new AsyncSeriesHook(['params']),
      /** @type {SyncHook<CompilationParams>} */
      compile: new SyncHook(['params']),
      /** @type {AsyncParallelHook<Compilation>} */
      make: new AsyncParallelHook(['compilation']),
      /** @type {AsyncSeriesHook<Compilation>} */
      afterCompile: new AsyncSeriesHook(['compilation']),

      /** @type {AsyncSeriesHook<Compiler>} */
      watchRun: new AsyncSeriesHook(['compiler']),
      /** @type {SyncHook<Error>} */
      failed: new SyncHook(['error']),
      /** @type {SyncHook<string, string>} */
      invalid: new SyncHook(['filename', 'changeTime']),
      /** @type {SyncHook} */
      watchClose: new SyncHook([]),

      // TODO the following hooks are weirdly located here
      // TODO move them for webpack 5
      /** @type {SyncHook} */
      environment: new SyncHook([]),
      /** @type {SyncHook} */
      afterEnvironment: new SyncHook([]),
      /** @type {SyncHook<Compiler>} */
      afterPlugins: new SyncHook(['compiler']),
      /** @type {SyncHook<Compiler>} */
      afterResolvers: new SyncHook(['compiler']),
      /** @type {SyncBailHook<string, EntryOptions>} */
      entryOption: new SyncBailHook(['context', 'entry'])
    }

    this._pluginCompat.tap('Compiler', options => {
      switch (options.name) {
        case 'additional-pass':
        case 'before-run':
        case 'run':
        case 'emit':
        case 'after-emit':
        case 'before-compile':
        case 'make':
        case 'after-compile':
        case 'watch-run':
          options.async = true
          break
      }
    })

    /** @type {string=} */
    this.name = undefined
    /** @type {Compilation=} */
    this.parentCompilation = undefined
    /** @type {string} */
    this.outputPath = ''

    this.outputFileSystem = null
    this.inputFileSystem = null

    /** @type {string|null} */
    this.recordsInputPath = null
    /** @type {string|null} */
    this.recordsOutputPath = null
    this.records = {}
    /** @type {Map<string, number>} */
    this.fileTimestamps = new Map()
    /** @type {Map<string, number>} */
    this.contextTimestamps = new Map()
    /** @type {ResolverFactory} */
    this.resolverFactory = new ResolverFactory()

    // TODO remove in webpack 5
    this.resolvers = {
      normal: {
        plugins: util.deprecate((hook, fn) => {
          this.resolverFactory.plugin('resolver normal', resolver => {
            resolver.plugin(hook, fn)
          })
        }, 'webpack: Using compiler.resolvers.normal is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate((...args) => {
          this.resolverFactory.plugin('resolver normal', resolver => {
            resolver.apply(...args)
          })
        }, 'webpack: Using compiler.resolvers.normal is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver normal", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      },
      loader: {
        plugins: util.deprecate((hook, fn) => {
          this.resolverFactory.plugin('resolver loader', resolver => {
            resolver.plugin(hook, fn)
          })
        }, 'webpack: Using compiler.resolvers.loader is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate((...args) => {
          this.resolverFactory.plugin('resolver loader', resolver => {
            resolver.apply(...args)
          })
        }, 'webpack: Using compiler.resolvers.loader is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver loader", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      },
      context: {
        plugins: util.deprecate((hook, fn) => {
          this.resolverFactory.plugin('resolver context', resolver => {
            resolver.plugin(hook, fn)
          })
        }, 'webpack: Using compiler.resolvers.context is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.plugin(/* … */);\n}); instead.'),
        apply: util.deprecate((...args) => {
          this.resolverFactory.plugin('resolver context', resolver => {
            resolver.apply(...args)
          })
        }, 'webpack: Using compiler.resolvers.context is deprecated.\n' + 'Use compiler.resolverFactory.plugin("resolver context", resolver => {\n  resolver.apply(/* … */);\n}); instead.')
      }
    }

    this.options = {}

    this.context = context

    this.requestShortener = new RequestShortener(context)

    /** @type {boolean} */
    this.running = false
  }

  watch(watchOptions, handler) {
    if (this.running) return handler(new ConcurrentCompilationError())

    this.running = true
    this.fileTimestamps = new Map()
    this.contextTimestamps = new Map()
    return new Watching(this, watchOptions, handler)
  }

  run(callback) {
    if (this.running) return callback(new ConcurrentCompilationError())

    const finalCallback = (err, stats) => {
      this.running = false

      if (callback !== undefined) return callback(err, stats)
    }

    const startTime = Date.now()

    this.running = true

    const onCompiled = (err, compilation) => {
      if (err) return finalCallback(err)

      if (this.hooks.shouldEmit.call(compilation) === false) {
        const stats = new Stats(compilation)
        stats.startTime = startTime
        stats.endTime = Date.now()
        this.hooks.done.callAsync(stats, err => {
          if (err) return finalCallback(err)
          return finalCallback(null, stats)
        })
        return
      }

      this.emitAssets(compilation, err => {
        if (err) return finalCallback(err)

        if (compilation.hooks.needAdditionalPass.call()) {
          compilation.needAdditionalPass = true

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, err => {
            if (err) return finalCallback(err)

            this.hooks.additionalPass.callAsync(err => {
              if (err) return finalCallback(err)
              this.compile(onCompiled)
            })
          })
          return
        }

        this.emitRecords(err => {
          if (err) return finalCallback(err)

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, err => {
            if (err) return finalCallback(err)
            return finalCallback(null, stats)
          })
        })
      })
    }

    this.hooks.beforeRun.callAsync(this, err => {
      if (err) return finalCallback(err)

      this.hooks.run.callAsync(this, err => {
        if (err) return finalCallback(err)

        this.readRecords(err => {
          if (err) return finalCallback(err)

          this.compile(onCompiled)
        })
      })
    })
  }

  runAsChild(callback) {
    this.compile((err, compilation) => {
      if (err) return callback(err)

      this.parentCompilation.children.push(compilation)
      for (const name of Object.keys(compilation.assets)) {
        this.parentCompilation.assets[name] = compilation.assets[name]
      }

      const entries = Array.from(
        compilation.entrypoints.values(),
        ep => ep.chunks
      ).reduce((array, chunks) => {
        return array.concat(chunks)
      }, [])

      return callback(null, entries, compilation)
    })
  }

  purgeInputFileSystem() {
    if (this.inputFileSystem && this.inputFileSystem.purge) {
      this.inputFileSystem.purge()
    }
  }

  emitAssets(compilation, callback) {
    let outputPath

    const emitFiles = err => {
      if (err) return callback(err)

      asyncLib.forEach(
        compilation.assets,
        (source, file, callback) => {
          let targetFile = file
          const queryStringIdx = targetFile.indexOf('?')
          if (queryStringIdx >= 0) {
            targetFile = targetFile.substr(0, queryStringIdx)
          }

          const writeOut = err => {
            if (err) return callback(err)
            const targetPath = this.outputFileSystem.join(
              outputPath,
              targetFile
            )
            if (source.existsAt === targetPath) {
              source.emitted = false
              return callback()
            }
            let content = source.source()

            if (!Buffer.isBuffer(content)) {
              content = Buffer.from(content, 'utf8')
            }

            source.existsAt = targetPath
            source.emitted = true
            this.outputFileSystem.writeFile(targetPath, content, callback)
          }

          if (targetFile.match(/\/|\\/)) {
            const dir = path.dirname(targetFile)
            this.outputFileSystem.mkdirp(
              this.outputFileSystem.join(outputPath, dir),
              writeOut
            )
          } else {
            writeOut()
          }
        },
        err => {
          if (err) return callback(err)

          this.hooks.afterEmit.callAsync(compilation, err => {
            if (err) return callback(err)

            return callback()
          })
        }
      )
    }

    this.hooks.emit.callAsync(compilation, err => {
      if (err) return callback(err)
      outputPath = compilation.getPath(this.outputPath)
      this.outputFileSystem.mkdirp(outputPath, emitFiles)
    })
  }

  emitRecords(callback) {
    if (!this.recordsOutputPath) return callback()
    const idx1 = this.recordsOutputPath.lastIndexOf('/')
    const idx2 = this.recordsOutputPath.lastIndexOf('\\')
    let recordsOutputPathDirectory = null
    if (idx1 > idx2) {
      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1)
    } else if (idx1 < idx2) {
      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2)
    }

    const writeFile = () => {
      this.outputFileSystem.writeFile(
        this.recordsOutputPath,
        JSON.stringify(this.records, undefined, 2),
        callback
      )
    }

    if (!recordsOutputPathDirectory) {
      return writeFile()
    }
    this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {
      if (err) return callback(err)
      writeFile()
    })
  }

  readRecords(callback) {
    if (!this.recordsInputPath) {
      this.records = {}
      return callback()
    }
    this.inputFileSystem.stat(this.recordsInputPath, err => {
      // It doesn't exist
      // We can ignore this.
      if (err) return callback()

      this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {
        if (err) return callback(err)

        try {
          this.records = parseJson(content.toString('utf-8'))
        } catch (e) {
          e.message = 'Cannot parse records: ' + e.message
          return callback(e)
        }

        return callback()
      })
    })
  }

  createChildCompiler(
    compilation,
    compilerName,
    compilerIndex,
    outputOptions,
    plugins
  ) {
    const childCompiler = new Compiler(this.context)
    if (Array.isArray(plugins)) {
      for (const plugin of plugins) {
        plugin.apply(childCompiler)
      }
    }
    for (const name in this.hooks) {
      if (
        ![
          'make',
          'compile',
          'emit',
          'afterEmit',
          'invalid',
          'done',
          'thisCompilation'
        ].includes(name)
      ) {
        if (childCompiler.hooks[name]) {
          childCompiler.hooks[name].taps = this.hooks[name].taps.slice()
        }
      }
    }
    childCompiler.name = compilerName
    childCompiler.outputPath = this.outputPath
    childCompiler.inputFileSystem = this.inputFileSystem
    childCompiler.outputFileSystem = null
    childCompiler.resolverFactory = this.resolverFactory
    childCompiler.fileTimestamps = this.fileTimestamps
    childCompiler.contextTimestamps = this.contextTimestamps

    const relativeCompilerName = makePathsRelative(this.context, compilerName)
    if (!this.records[relativeCompilerName]) {
      this.records[relativeCompilerName] = []
    }
    if (this.records[relativeCompilerName][compilerIndex]) {
      childCompiler.records = this.records[relativeCompilerName][compilerIndex]
    } else {
      this.records[relativeCompilerName].push((childCompiler.records = {}))
    }

    childCompiler.options = Object.create(this.options)
    childCompiler.options.output = Object.create(childCompiler.options.output)
    for (const name in outputOptions) {
      childCompiler.options.output[name] = outputOptions[name]
    }
    childCompiler.parentCompilation = compilation

    compilation.hooks.childCompiler.call(
      childCompiler,
      compilerName,
      compilerIndex
    )

    return childCompiler
  }

  isChild() {
    return !!this.parentCompilation
  }

  createCompilation() {
    return new Compilation(this)
  }

  newCompilation(params) {
    const compilation = this.createCompilation()
    compilation.fileTimestamps = this.fileTimestamps
    compilation.contextTimestamps = this.contextTimestamps
    compilation.name = this.name
    compilation.records = this.records
    compilation.compilationDependencies = params.compilationDependencies
    this.hooks.thisCompilation.call(compilation, params)
    this.hooks.compilation.call(compilation, params)
    return compilation
  }

  createNormalModuleFactory() {
    const normalModuleFactory = new NormalModuleFactory(
      this.options.context,
      this.resolverFactory,
      this.options.module || {}
    )
    this.hooks.normalModuleFactory.call(normalModuleFactory)
    return normalModuleFactory
  }

  createContextModuleFactory() {
    const contextModuleFactory = new ContextModuleFactory(this.resolverFactory)
    this.hooks.contextModuleFactory.call(contextModuleFactory)
    return contextModuleFactory
  }

  newCompilationParams() {
    const params = {
      normalModuleFactory: this.createNormalModuleFactory(),
      contextModuleFactory: this.createContextModuleFactory(),
      compilationDependencies: new Set()
    }
    return params
  }

  compile(callback) {
    const params = this.newCompilationParams()
    this.hooks.beforeCompile.callAsync(params, err => {
      if (err) return callback(err)

      this.hooks.compile.call(params)

      const compilation = this.newCompilation(params)

      this.hooks.make.callAsync(compilation, err => {
        if (err) return callback(err)

        compilation.finish()

        compilation.seal(err => {
          if (err) return callback(err)

          this.hooks.afterCompile.callAsync(compilation, err => {
            if (err) return callback(err)

            return callback(null, compilation)
          })
        })
      })
    })
  }
}
```

##### compiler 和 compilation

- Compiler 类(`./lib/Compiler.js`)：webpack 的主要引擎，在 compiler 对象记录了完整的 webpack 环境信息，在 webpack 从启动到结束，compiler 只会生成一次。

- Compilation 类(`./lib/Compilation.js`)：代表了一次单一的版本构建和生成资源。compilation 编译作业可以多次执行，比如 webpack 工作在 watch 模式下，每次监测到源文件发生变化时，都会重新实例化一个 compilation 对象。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。

#### compiler.options = new WebpackOptionsApply().process(options, compiler)

主要完成大量内建插件的装载

lib/WebpackOptionsApply.js

```js
class WebpackOptionsApply extends OptionsApply {
  constructor() {
    super()
  }

  process(options, compiler) {
    let ExternalsPlugin
    compiler.outputPath = options.output.path
    compiler.recordsInputPath = options.recordsInputPath || options.recordsPath
    compiler.recordsOutputPath =
      options.recordsOutputPath || options.recordsPath
    compiler.name = options.name
    compiler.dependencies = options.dependencies
    if (typeof options.target === 'string') {
      let JsonpTemplatePlugin
      let FetchCompileWasmTemplatePlugin
      let ReadFileCompileWasmTemplatePlugin
      let NodeSourcePlugin
      let NodeTargetPlugin
      let NodeTemplatePlugin

      switch (options.target) {
        case 'web':
          JsonpTemplatePlugin = require('./web/JsonpTemplatePlugin')
          FetchCompileWasmTemplatePlugin = require('./web/FetchCompileWasmTemplatePlugin')
          NodeSourcePlugin = require('./node/NodeSourcePlugin')
          new JsonpTemplatePlugin().apply(compiler)
          new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeSourcePlugin(options.node).apply(compiler)
          new LoaderTargetPlugin(options.target).apply(compiler)
          break
        case 'webworker': {
          let WebWorkerTemplatePlugin = require('./webworker/WebWorkerTemplatePlugin')
          FetchCompileWasmTemplatePlugin = require('./web/FetchCompileWasmTemplatePlugin')
          NodeSourcePlugin = require('./node/NodeSourcePlugin')
          new WebWorkerTemplatePlugin().apply(compiler)
          new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeSourcePlugin(options.node).apply(compiler)
          new LoaderTargetPlugin(options.target).apply(compiler)
          break
        }
        case 'node':
        case 'async-node':
          NodeTemplatePlugin = require('./node/NodeTemplatePlugin')
          ReadFileCompileWasmTemplatePlugin = require('./node/ReadFileCompileWasmTemplatePlugin')
          NodeTargetPlugin = require('./node/NodeTargetPlugin')
          new NodeTemplatePlugin({
            asyncChunkLoading: options.target === 'async-node'
          }).apply(compiler)
          new ReadFileCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeTargetPlugin().apply(compiler)
          new LoaderTargetPlugin('node').apply(compiler)
          break
        case 'node-webkit':
          JsonpTemplatePlugin = require('./web/JsonpTemplatePlugin')
          NodeTargetPlugin = require('./node/NodeTargetPlugin')
          ExternalsPlugin = require('./ExternalsPlugin')
          new JsonpTemplatePlugin().apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeTargetPlugin().apply(compiler)
          new ExternalsPlugin('commonjs', 'nw.gui').apply(compiler)
          new LoaderTargetPlugin(options.target).apply(compiler)
          break
        case 'electron-main':
          NodeTemplatePlugin = require('./node/NodeTemplatePlugin')
          NodeTargetPlugin = require('./node/NodeTargetPlugin')
          ExternalsPlugin = require('./ExternalsPlugin')
          new NodeTemplatePlugin({
            asyncChunkLoading: true
          }).apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeTargetPlugin().apply(compiler)
          new ExternalsPlugin('commonjs', [
            'app',
            'auto-updater',
            'browser-window',
            'clipboard',
            'content-tracing',
            'crash-reporter',
            'dialog',
            'electron',
            'global-shortcut',
            'ipc',
            'ipc-main',
            'menu',
            'menu-item',
            'native-image',
            'original-fs',
            'power-monitor',
            'power-save-blocker',
            'protocol',
            'screen',
            'session',
            'shell',
            'tray',
            'web-contents'
          ]).apply(compiler)
          new LoaderTargetPlugin(options.target).apply(compiler)
          break
        case 'electron-renderer':
          JsonpTemplatePlugin = require('./web/JsonpTemplatePlugin')
          FetchCompileWasmTemplatePlugin = require('./web/FetchCompileWasmTemplatePlugin')
          NodeTargetPlugin = require('./node/NodeTargetPlugin')
          ExternalsPlugin = require('./ExternalsPlugin')
          new JsonpTemplatePlugin().apply(compiler)
          new FetchCompileWasmTemplatePlugin({
            mangleImports: options.optimization.mangleWasmImports
          }).apply(compiler)
          new FunctionModulePlugin().apply(compiler)
          new NodeTargetPlugin().apply(compiler)
          new ExternalsPlugin('commonjs', [
            'clipboard',
            'crash-reporter',
            'desktop-capturer',
            'electron',
            'ipc',
            'ipc-renderer',
            'native-image',
            'original-fs',
            'remote',
            'screen',
            'shell',
            'web-frame'
          ]).apply(compiler)
          new LoaderTargetPlugin(options.target).apply(compiler)
          break
        default:
          throw new Error("Unsupported target '" + options.target + "'.")
      }
    } else if (options.target !== false) {
      options.target(compiler)
    } else {
      throw new Error("Unsupported target '" + options.target + "'.")
    }

    if (options.output.library || options.output.libraryTarget !== 'var') {
      const LibraryTemplatePlugin = require('./LibraryTemplatePlugin')
      new LibraryTemplatePlugin(
        options.output.library,
        options.output.libraryTarget,
        options.output.umdNamedDefine,
        options.output.auxiliaryComment || '',
        options.output.libraryExport
      ).apply(compiler)
    }
    if (options.externals) {
      ExternalsPlugin = require('./ExternalsPlugin')
      new ExternalsPlugin(
        options.output.libraryTarget,
        options.externals
      ).apply(compiler)
    }

    let noSources
    let legacy
    let modern
    let comment
    if (
      options.devtool &&
      (options.devtool.includes('sourcemap') ||
        options.devtool.includes('source-map'))
    ) {
      const hidden = options.devtool.includes('hidden')
      const inline = options.devtool.includes('inline')
      const evalWrapped = options.devtool.includes('eval')
      const cheap = options.devtool.includes('cheap')
      const moduleMaps = options.devtool.includes('module')
      noSources = options.devtool.includes('nosources')
      legacy = options.devtool.includes('@')
      modern = options.devtool.includes('#')
      comment =
        legacy && modern
          ? '\n/*\n//@ source' +
            'MappingURL=[url]\n//# source' +
            'MappingURL=[url]\n*/'
          : legacy
          ? '\n/*\n//@ source' + 'MappingURL=[url]\n*/'
          : modern
          ? '\n//# source' + 'MappingURL=[url]'
          : null
      const Plugin = evalWrapped
        ? EvalSourceMapDevToolPlugin
        : SourceMapDevToolPlugin
      new Plugin({
        filename: inline ? null : options.output.sourceMapFilename,
        moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
        fallbackModuleFilenameTemplate:
          options.output.devtoolFallbackModuleFilenameTemplate,
        append: hidden ? false : comment,
        module: moduleMaps ? true : cheap ? false : true,
        columns: cheap ? false : true,
        lineToLine: options.output.devtoolLineToLine,
        noSources: noSources,
        namespace: options.output.devtoolNamespace
      }).apply(compiler)
    } else if (options.devtool && options.devtool.includes('eval')) {
      legacy = options.devtool.includes('@')
      modern = options.devtool.includes('#')
      comment =
        legacy && modern
          ? '\n//@ sourceURL=[url]\n//# sourceURL=[url]'
          : legacy
          ? '\n//@ sourceURL=[url]'
          : modern
          ? '\n//# sourceURL=[url]'
          : null
      new EvalDevToolModulePlugin({
        sourceUrlComment: comment,
        moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
        namespace: options.output.devtoolNamespace
      }).apply(compiler)
    }

    new JavascriptModulesPlugin().apply(compiler)
    new JsonModulesPlugin().apply(compiler)
    new WebAssemblyModulesPlugin({
      mangleImports: options.optimization.mangleWasmImports
    }).apply(compiler)

    new EntryOptionPlugin().apply(compiler)
    compiler.hooks.entryOption.call(options.context, options.entry)

    new CompatibilityPlugin().apply(compiler)
    new HarmonyModulesPlugin(options.module).apply(compiler)
    new AMDPlugin(options.module, options.amd || {}).apply(compiler)
    new CommonJsPlugin(options.module).apply(compiler)
    new LoaderPlugin().apply(compiler)
    new NodeStuffPlugin(options.node).apply(compiler)
    new RequireJsStuffPlugin().apply(compiler)
    new APIPlugin().apply(compiler)
    new ConstPlugin().apply(compiler)
    new UseStrictPlugin().apply(compiler)
    new RequireIncludePlugin().apply(compiler)
    new RequireEnsurePlugin().apply(compiler)
    new RequireContextPlugin(
      options.resolve.modules,
      options.resolve.extensions,
      options.resolve.mainFiles
    ).apply(compiler)
    new ImportPlugin(options.module).apply(compiler)
    new SystemPlugin(options.module).apply(compiler)

    if (typeof options.mode !== 'string') {
      new WarnNoModeSetPlugin().apply(compiler)
    }

    new EnsureChunkConditionsPlugin().apply(compiler)
    if (options.optimization.removeAvailableModules) {
      new RemoveParentModulesPlugin().apply(compiler)
    }
    if (options.optimization.removeEmptyChunks) {
      new RemoveEmptyChunksPlugin().apply(compiler)
    }
    if (options.optimization.mergeDuplicateChunks) {
      new MergeDuplicateChunksPlugin().apply(compiler)
    }
    if (options.optimization.flagIncludedChunks) {
      new FlagIncludedChunksPlugin().apply(compiler)
    }
    if (options.optimization.sideEffects) {
      new SideEffectsFlagPlugin().apply(compiler)
    }
    if (options.optimization.providedExports) {
      new FlagDependencyExportsPlugin().apply(compiler)
    }
    if (options.optimization.usedExports) {
      new FlagDependencyUsagePlugin().apply(compiler)
    }
    if (options.optimization.concatenateModules) {
      new ModuleConcatenationPlugin().apply(compiler)
    }
    if (options.optimization.splitChunks) {
      new SplitChunksPlugin(options.optimization.splitChunks).apply(compiler)
    }
    if (options.optimization.runtimeChunk) {
      new RuntimeChunkPlugin(options.optimization.runtimeChunk).apply(compiler)
    }
    if (options.optimization.noEmitOnErrors) {
      new NoEmitOnErrorsPlugin().apply(compiler)
    }
    if (options.optimization.checkWasmTypes) {
      new WasmFinalizeExportsPlugin().apply(compiler)
    }
    let moduleIds = options.optimization.moduleIds
    if (moduleIds === undefined) {
      // TODO webpack 5 remove all these options
      if (options.optimization.occurrenceOrder) {
        moduleIds = 'size'
      }
      if (options.optimization.namedModules) {
        moduleIds = 'named'
      }
      if (options.optimization.hashedModuleIds) {
        moduleIds = 'hashed'
      }
      if (moduleIds === undefined) {
        moduleIds = 'natural'
      }
    }
    if (moduleIds) {
      switch (moduleIds) {
        case 'natural':
          // TODO webpack 5: see hint in Compilation.sortModules
          break
        case 'named':
          new NamedModulesPlugin().apply(compiler)
          break
        case 'hashed':
          new HashedModuleIdsPlugin().apply(compiler)
          break
        case 'size':
          new OccurrenceModuleOrderPlugin({
            prioritiseInitial: true
          }).apply(compiler)
          break
        case 'total-size':
          new OccurrenceModuleOrderPlugin({
            prioritiseInitial: false
          }).apply(compiler)
          break
        default:
          throw new Error(
            `webpack bug: moduleIds: ${moduleIds} is not implemented`
          )
      }
    }
    let chunkIds = options.optimization.chunkIds
    if (chunkIds === undefined) {
      // TODO webpack 5 remove all these options
      if (options.optimization.occurrenceOrder) {
        // This looks weird but it's for backward-compat
        // This bug already existed before adding this feature
        chunkIds = 'total-size'
      }
      if (options.optimization.namedChunks) {
        chunkIds = 'named'
      }
      if (chunkIds === undefined) {
        chunkIds = 'natural'
      }
    }
    if (chunkIds) {
      switch (chunkIds) {
        case 'natural':
          new NaturalChunkOrderPlugin().apply(compiler)
          break
        case 'named':
          // TODO webapck 5: for backward-compat this need to have OccurrenceChunkOrderPlugin too
          // The NamedChunksPlugin doesn't give every chunk a name
          // This should be fixed, and the OccurrenceChunkOrderPlugin should be removed here.
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: false
          }).apply(compiler)
          new NamedChunksPlugin().apply(compiler)
          break
        case 'size':
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: true
          }).apply(compiler)
          break
        case 'total-size':
          new OccurrenceChunkOrderPlugin({
            prioritiseInitial: false
          }).apply(compiler)
          break
        default:
          throw new Error(
            `webpack bug: chunkIds: ${chunkIds} is not implemented`
          )
      }
    }
    if (options.optimization.nodeEnv) {
      new DefinePlugin({
        'process.env.NODE_ENV': JSON.stringify(options.optimization.nodeEnv)
      }).apply(compiler)
    }
    if (options.optimization.minimize) {
      for (const minimizer of options.optimization.minimizer) {
        minimizer.apply(compiler)
      }
    }

    if (options.performance) {
      new SizeLimitsPlugin(options.performance).apply(compiler)
    }

    new TemplatedPathPlugin().apply(compiler)

    new RecordIdsPlugin({
      portableIds: options.optimization.portableRecords
    }).apply(compiler)

    new WarnCaseSensitiveModulesPlugin().apply(compiler)

    if (options.cache) {
      const CachePlugin = require('./CachePlugin')
      new CachePlugin(
        typeof options.cache === 'object' ? options.cache : null
      ).apply(compiler)
    }

    compiler.hooks.afterPlugins.call(compiler)
    if (!compiler.inputFileSystem) {
      throw new Error('No input filesystem provided')
    }
    compiler.resolverFactory.hooks.resolveOptions
      .for('normal')
      .tap('WebpackOptionsApply', resolveOptions => {
        return Object.assign(
          {
            fileSystem: compiler.inputFileSystem
          },
          options.resolve,
          resolveOptions
        )
      })
    compiler.resolverFactory.hooks.resolveOptions
      .for('context')
      .tap('WebpackOptionsApply', resolveOptions => {
        return Object.assign(
          {
            fileSystem: compiler.inputFileSystem,
            resolveToContext: true
          },
          options.resolve,
          resolveOptions
        )
      })
    compiler.resolverFactory.hooks.resolveOptions
      .for('loader')
      .tap('WebpackOptionsApply', resolveOptions => {
        return Object.assign(
          {
            fileSystem: compiler.inputFileSystem
          },
          options.resolveLoader,
          resolveOptions
        )
      })
    compiler.hooks.afterResolvers.call(compiler)
    return options
  }
}
```

### compiler.run()

```js
class Compile {
  ///...
  run(callback) {
    if (this.running) return callback(new ConcurrentCompilationError())

    const finalCallback = (err, stats) => {
      this.running = false

      if (callback !== undefined) return callback(err, stats)
    }

    const startTime = Date.now()

    this.running = true

    const onCompiled = (err, compilation) => {
      if (err) return finalCallback(err)

      if (this.hooks.shouldEmit.call(compilation) === false) {
        const stats = new Stats(compilation)
        stats.startTime = startTime
        stats.endTime = Date.now()
        this.hooks.done.callAsync(stats, err => {
          if (err) return finalCallback(err)
          return finalCallback(null, stats)
        })
        return
      }

      this.emitAssets(compilation, err => {
        if (err) return finalCallback(err)

        if (compilation.hooks.needAdditionalPass.call()) {
          compilation.needAdditionalPass = true

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, err => {
            if (err) return finalCallback(err)

            this.hooks.additionalPass.callAsync(err => {
              if (err) return finalCallback(err)
              this.compile(onCompiled)
            })
          })
          return
        }

        this.emitRecords(err => {
          if (err) return finalCallback(err)

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, err => {
            if (err) return finalCallback(err)
            return finalCallback(null, stats)
          })
        })
      })
    }

    this.hooks.beforeRun.callAsync(this, err => {
      if (err) return finalCallback(err)

      this.hooks.run.callAsync(this, err => {
        if (err) return finalCallback(err)

        this.readRecords(err => {
          if (err) return finalCallback(err)

          this.compile(onCompiled)
        })
      })
    })
  }
  readRecords(callback) {
    if (!this.recordsInputPath) {
      this.records = {}
      return callback()
    }
    this.inputFileSystem.stat(this.recordsInputPath, err => {
      // It doesn't exist
      // We can ignore this.
      if (err) return callback()

      this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {
        if (err) return callback(err)

        try {
          this.records = parseJson(content.toString('utf-8'))
        } catch (e) {
          e.message = 'Cannot parse records: ' + e.message
          return callback(e)
        }

        return callback()
      })
    })
  }
}
```
